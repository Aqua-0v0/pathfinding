<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MRA* 3D / A* 3D 体素寻路可视化（0.25m 网格）</title>
  <style>
    :root{
      --bg:#0b0d10; --panel:#12161c; --text:#e6e8eb; --muted:#9aa4af; --line:#222a35;
      --accent:#2a7bd6; --warn:#d66f2a;
    }
    html,body{height:100%;}
    body{margin:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}
    .wrap{display:grid; grid-template-columns: 380px 1fr; gap:14px; padding:14px; box-sizing:border-box; height:100%;}
    .panel{background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:14px; overflow:auto;}
    .panel h1{font-size:16px; margin:0 0 10px;}
    .panel h2{font-size:13px; margin:16px 0 8px; color:var(--muted); font-weight:600; letter-spacing:.2px;}
    .row{display:flex; gap:10px; align-items:center; margin:10px 0;}
    .row label{font-size:12px; color:var(--muted); width:140px; flex:0 0 auto;}
    .row input[type="number"], .row input[type="text"], .row select{
      flex:1; background:#0f1318; color:var(--text); border:1px solid var(--line); border-radius:10px; padding:8px 10px;
    }
    .row input[type="range"]{flex:1;}
    .row .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .btns{display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px;}
    button{
      background:#1a2230; color:var(--text); border:1px solid var(--line); border-radius:12px; padding:10px; cursor:pointer;
    }
    button:hover{filter:brightness(1.08);}
    button:disabled{opacity:.5; cursor:not-allowed;}
    .hint{font-size:12px; color:var(--muted); line-height:1.4;}
    .stat{
      font-size:12px; white-space:pre-wrap; color:var(--text);
      background:#0f1318; border:1px solid var(--line); border-radius:12px; padding:10px;
    }
    .view{
      background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:10px;
      display:flex; flex-direction:column; gap:10px;
    }
    .topbar{display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .badge{font-size:12px; color:var(--muted);}
    .legend{display:flex; flex-wrap:wrap; gap:8px; font-size:12px; color:var(--muted);}
    .chip{display:flex; align-items:center; gap:6px;}
    .sw{width:12px; height:12px; border-radius:4px; border:1px solid #2b3442;}
    canvas{background:#0f1318; border-radius:12px; width:100%; height:100%; display:block; touch-action:none;}
    .toolbar{
      display:flex; flex-wrap:wrap; gap:8px;
    }
    .tool{
      padding:8px 10px; font-size:12px; border-radius:999px;
      background:#0f1318; border:1px solid var(--line); color:var(--text);
      cursor:pointer; user-select:none;
    }
    .tool.active{outline:2px solid rgba(42,123,214,.55); border-color:#2a7bd6;}
    .tool small{color:var(--muted); font-size:11px;}
    details{border:1px solid var(--line); border-radius:12px; padding:10px; background:#0f1318;}
    details summary{cursor:pointer; color:var(--text);}
    .kv{display:grid; grid-template-columns: 1fr auto; gap:6px 10px; font-size:12px; color:var(--muted); margin-top:8px;}
    .kv div:nth-child(2n){text-align:right; color:var(--text);}
  </style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h1>MRA* 3D / A* 3D 体素寻路可视化（0.25m 网格）</h1>

    <h2>地图 / 数据结构</h2>
    <div class="row">
      <label>地图大小 X (m)</label>
      <input id="mapW" type="number" min="32" step="32" value="32">
    </div>
    <div class="row">
      <label>地图大小 Z (m)</label>
      <input id="mapH" type="number" min="32" step="32" value="32">
    </div>
    <div class="hint">说明：每 1m×1m 有 4×4=16 个子格（0.25m）。Chunk 为 32m×32m（与 Go 版一致）。</div>

    <h2>编辑工具</h2>
    <div class="toolbar" id="toolbar">
      <div class="tool active" data-tool="terrain">地形 <small>(1m 低精)</small></div>
      <div class="tool" data-tool="blockLP">阻挡 <small>(1m 低精)</small></div>
      <div class="tool" data-tool="blockHP">阻挡 <small>(0.25m 高精)</small></div>
      <div class="tool" data-tool="erase">擦除 <small>(清阻挡)</small></div>
      <div class="tool" data-tool="start">起点</div>
      <div class="tool" data-tool="goal">终点</div>
      <div class="tool" data-tool="inspect">查看</div>
    </div>

    <div class="row">
      <label>刷子半径</label>
      <select id="brush">
        <option value="0">0（单格）</option>
        <option value="1" selected>1</option>
        <option value="2">2</option>
        <option value="4">4</option>
      </select>
    </div>

    <div class="row">
      <label>Terrain 高度 (m)</label>
      <input id="terrainH" type="number" min="0" max="30" step="0.05" value="0.00">
    </div>
    <div class="row">
      <label>Terrain Texture</label>
      <input id="terrainTex" type="number" min="0" step="1" value="1">
    </div>

    <div class="row">
      <label>阻挡 MinY (m)</label>
      <input id="blkMin" type="number" min="0" max="200" step="0.05" value="0.00">
    </div>
    <div class="row">
      <label>阻挡 MaxY (m)</label>
      <input id="blkMax" type="number" min="0" max="200" step="0.05" value="2.00">
    </div>
    <div class="row">
      <label>阻挡 Texture</label>
      <input id="blkTex" type="number" min="0" step="1" value="3">
    </div>
    <div class="hint">阻挡 Span：表示 [MinY, MaxY] 都是阻挡。Y 精度 0.05m（与 Go 版一致）。</div>

    <h2>寻路参数</h2>
    <div class="row">
      <label>算法</label>
      <select id="algo">
        <option value="astar">A*</option>
        <option value="mra" selected>MRA*</option>
      </select>
    </div>
    <div class="row">
      <label>w1 (WA*)</label>
      <input id="w1" type="number" min="1" max="10" step="0.1" value="2.0">
    </div>
    <div class="row">
      <label>w2 (gate)</label>
      <input id="w2" type="number" min="1" max="10" step="0.1" value="1.5">
    </div>
    <div class="row">
      <label>速度 (step/s)</label>
      <input id="speed" type="range" min="1" max="120" value="30">
    </div>

    <div class="row">
      <label>体型 (固定)</label>
      <div class="hint" style="flex:1">x,z 占用 2×2 子格（0.5m×0.5m）</div>
    </div>
    <div class="row">
      <label>物体高度 (m)</label>
      <input id="agentH" type="number" min="0.3" max="5" step="0.05" value="1.10">
    </div>
    <div class="row">
      <label>可上台阶 (m)</label>
      <input id="stepUp" type="number" min="0" max="5" step="0.05" value="1.10">
    </div>
    <div class="row">
      <label>可下落差 (m)</label>
      <input id="stepDown" type="number" min="0" max="65535" step="0.05" value="65535">
    </div>

    <div class="row">
      <label>禁止落脚 Texture</label>
      <input id="banTex" class="mono" type="text" value="2">
    </div>
    <div class="row">
      <label>可忽略阻挡 Texture</label>
      <input id="ignoreTex" type="number" min="0" step="1" value="0">
    </div>

    <div class="hint">
      Texture 说明：Texture 是 bitmask（可用逗号分隔多个值，会按 OR 合并）。例如 <span class="mono">2,8,16</span>。<br/>
      • 禁止落脚 Texture：与落脚点 Texture 做 <span class="mono">&amp;</span>，非 0 则禁止落脚。<br/>
      • 可忽略阻挡 Texture：与 Span.Texture 做 <span class="mono">&amp;</span>，非 0 则“可被忽略”，但只忽略高于当前落脚点的部分（按 map.go 注释）。
    </div>

    <h2>起点 / 终点</h2>
    <div class="row">
      <label>端点 Y 模式</label>
      <select id="endYMode">
        <option value="auto" selected>自动（吸附落脚点）</option>
        <option value="manual">手动（使用输入 Y）</option>
      </select>
    </div>
    <div class="row">
      <label>起点 Y (m)</label>
      <input id="startY" type="number" min="0" max="2000" step="0.05" value="0.00">
    </div>
    <div class="row">
      <label>终点 Y (m)</label>
      <input id="goalY" type="number" min="0" max="2000" step="0.05" value="0.00">
    </div>
    <div class="hint">自动模式：点击起点/终点只设置 x,z，y 会自动选择该 footprint 内“最低可落脚点”；手动模式：使用输入 y（若在阻挡里/高度不足会直接失败）。</div>

    <h2>运行控制</h2>
    <div class="btns">
      <button id="reset">重置</button>
      <button id="clear">清空阻挡</button>
      <button id="step">单步</button>
      <button id="run">开始</button>
      <button id="pause" disabled>暂停</button>
      <button id="finish">跑到结束</button>
    </div>

    <div style="height:10px"></div>
    <div class="stat" id="stat">状态：未开始</div>

    <div style="height:10px"></div>
    <details>
      <summary>选中单元信息 / Span 列表</summary>
      <div class="hint">在“查看”工具下点击地面可选中单元；或在任意工具下按住 <span class="mono">Ctrl</span> 点击。</div>
      <div class="kv" id="inspect"></div>
    </details>

    <div style="height:10px"></div>
    <div class="hint">
      交互：<br/>
      • 左键：按当前工具绘制（拖拽连续绘制）<br/>
      • 右键拖拽：旋转相机 &nbsp; • 中键拖拽：平移 &nbsp; • 滚轮：缩放<br/>
      • Ctrl+左键：查看单元 Span<br/>
    </div>

  </div>

  <div class="view">
    <div class="topbar">
      <div class="badge">3D 视图（Canvas 软渲染）</div>
      <div class="legend">
        <div class="chip"><span class="sw" style="background:#2a7bd6"></span> 起点</div>
        <div class="chip"><span class="sw" style="background:#d66f2a"></span> 终点</div>
        <div class="chip"><span class="sw" style="background:#2a1b3b"></span> PATH</div>
        <div class="chip"><span class="sw" style="background:#1b3b22"></span> OPEN</div>
        <div class="chip"><span class="sw" style="background:#3b2b1b"></span> CLOSED</div>
        <div class="chip"><span class="sw" style="background:#263241"></span> 阻挡</div>
      </div>
    </div>
    <canvas id="cv"></canvas>
  </div>
</div>

<script>
/* =========================================================================================
   3D MRA* / A* Visualizer (single-file, no external libs)
   - Grid: 0.25m (4x4 per 1m cell)
   - Terrain: always low precision (1m), MinY=0
   - Obstacles: low precision (1m) or high precision (0.25m)
   - Footprint: fixed 2x2 subcells (0.5m x 0.5m)
   - Connectivity: 8-connected in x,z (per Go comment)
   ========================================================================================= */

// =============================== Constants & Helpers ===============================
const CELL = 0.25;          // meters per subcell
const SUB = 4;              // subcells per meter (x,z)
const FAST_GRID_SET_SIZE = 32; // Chunk size in meters (as Go)

const clamp = (v,a,b)=>Math.max(a, Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;

const mToU = (m)=>{ // meters -> uint16 units (0.05m per unit)
  // allow large values for debugging; keep within uint16 range
  const u = Math.round(m / 0.05);
  return clamp(u, 0, 65535) | 0;
};
const uToM = (u)=> (u * 0.05);

// parse comma-separated integers into a single bitmask (OR)
// 例："2,8,16" => 2|8|16
function parseTexMask(str){
  const s = (str||'').trim();
  if(!s) return 0;
  let mask = 0;
  for(const part of s.split(',')){
    const t = part.trim();
    if(!t) continue;
    const n = Number(t);
    if(Number.isFinite(n)) mask |= (n|0);
  }
  return mask|0;
}

// =============================== Go-like Data Structures ===============================
// Span: blocking interval [MinY, MaxY] with Texture
class Span {
  constructor(minY=0, maxY=0, texture=0){
    this.MinY = minY|0;
    this.MaxY = maxY|0;
    this.Texture = texture|0;
  }
}

// HighPrecisionColumn: per subcell spans (16 entries)
class HighPrecisionColumn {
  constructor(){
    // Spans[gridIndex] = Span[]
    this.Spans = Array.from({length:16}, ()=>[]);
  }
}

// Column: 1m x 1m cell
// Mask bits (as Go comment):
//  bit0: ColumnIsTerrain (only terrain)
//  bit1: ColumnIsLowPrecision (terrain + Other)
class Column {
  constructor(){
    this.Mask = 1; // terrain-only by default
    this.Terrain = new Span(0, 0, 1); // default height 0, texture 1
    this.Other = null;               // Span[] (low precision obstacles)
    this.HighPrecision = null;       // HighPrecisionColumn
  }
  ColumnIsTerrain(){ return (this.Mask & 1) > 0; }
  ColumnIsLowPrecision(){ return (this.Mask & 2) > 0; }

  // Return [terrainSpan, obstacleSpans] for a PointForSearchPath
  GetSpans(p){
    if(this.ColumnIsTerrain()){
      return [this.Terrain, []];
    }
    if(this.ColumnIsLowPrecision()){
      return [this.Terrain, (this.Other||[])];
    }
    // High precision:
    const idx = p.GridIndex|0;
    const hp = this.HighPrecision;
    if(!hp) return [this.Terrain, []];
    return [this.Terrain, (hp.Spans[idx]||[])];
  }
}

// Chunk: 32m x 32m columns => 32*32 entries
class Chunk {
  constructor(){
    this.cols = Array.from({length:FAST_GRID_SET_SIZE*FAST_GRID_SET_SIZE}, ()=> new Column());
  }
}

// Space: chunked map
class Space {
  constructor(){
    this.Map = []; // Chunk[] | null entries
    this.minX = 0;
    this.minZ = 0;
    this.width = 0;  // chunks in x
    this.height = 0; // chunks in z
    this.spaceWidth = 0;  // meters
    this.spaceHeight = 0; // meters
  }

  InitWidthAndHeight(spaceWidth, spaceHeight){
    // spaceWidth/Height must be multiple of 32m (per Go comment)
    this.spaceWidth = spaceWidth|0;
    this.spaceHeight = spaceHeight|0;
    this.width = Math.ceil(spaceWidth / FAST_GRID_SET_SIZE);
    this.height = Math.ceil(spaceHeight / FAST_GRID_SET_SIZE);
    const n = this.width * this.height;
    this.Map = Array.from({length:n}, ()=> null);
  }

  _chunkIndex(mx, mz){
    const x = (mx|0) - this.minX;
    const z = (mz|0) - this.minZ;
    const cx = (x / FAST_GRID_SET_SIZE) | 0;
    const cz = (z / FAST_GRID_SET_SIZE) | 0;
    return cx + cz * this.width;
  }

  _colIndexInChunk(mx, mz){
    const x = (mx|0) - this.minX;
    const z = (mz|0) - this.minZ;
    const ox = x & (FAST_GRID_SET_SIZE - 1); // because 32 is power of 2
    const oz = z & (FAST_GRID_SET_SIZE - 1);
    return ox + oz * FAST_GRID_SET_SIZE;
  }

  GetColumnByMeter(mx, mz){
    const idx = this._chunkIndex(mx, mz);
    if(idx < 0 || idx >= this.Map.length) return [null, false];
    const ch = this.Map[idx];
    if(!ch) return [null, false];
    const ci = this._colIndexInChunk(mx, mz);
    return [ch.cols[ci], true];
  }

  GetOrCreateColumnByMeter(mx, mz){
    const idx = this._chunkIndex(mx, mz);
    if(idx < 0 || idx >= this.Map.length) return null;
    if(!this.Map[idx]) this.Map[idx] = new Chunk();
    const ch = this.Map[idx];
    const ci = this._colIndexInChunk(mx, mz);
    return ch.cols[ci];
  }
}

// PointForSearchPath: subcell-based node, with y in 0.05m units
class PointForSearchPath {
  constructor(xMeters, zMeters, xOff, zOff, yUnits){
    this.X = xMeters|0;
    this.Z = zMeters|0;
    this.Y = yUnits|0;
    this.XOffSet = xOff|0; // 0..3
    this.ZOffSet = zOff|0; // 0..3
    this.GridIndex = 0;
    this.CalcGridIndex();
  }
  CalcGridIndex(){
    this.GridIndex = (this.XOffSet * 4 + this.ZOffSet) | 0;
  }
}

// =============================== Map Wrapper (fine-grid access) ===============================
class MapData {
  constructor(widthM=32, heightM=32){
    this.space = new Space();
    this.resize(widthM, heightM);
  }

  resize(widthM, heightM){
    this.widthM = widthM|0;
    this.heightM = heightM|0;
    this.widthFine = this.widthM * SUB;
    this.heightFine = this.heightM * SUB;
    this.space = new Space();
    this.space.InitWidthAndHeight(this.widthM, this.heightM);
    // Lazily allocate chunks on edit (to keep it light).
  }

  inFineBounds(xi, zi){
    return xi>=0 && zi>=0 && xi < this.widthFine && zi < this.heightFine;
  }

  // fine (0.25m) -> (meter + offsets)
  _fineToPoint(xi, zi, yUnits){
    const xm = (xi / SUB) | 0;
    const zm = (zi / SUB) | 0;
    const xo = xi & (SUB-1);
    const zo = zi & (SUB-1);
    return new PointForSearchPath(xm, zm, xo, zo, yUnits);
  }

  getSpansAtFine(xi, zi, yUnits){
    if(!this.inFineBounds(xi,zi)) return [null, null];
    const p = this._fineToPoint(xi, zi, yUnits|0);
    const [col, ok] = this.space.GetColumnByMeter(p.X, p.Z);
    if(!ok || !col){
      // Unallocated columns are "default terrain only": height 0, texture 1
      const terrain = new Span(0, 0, 1);
      return [terrain, []];
    }
    return col.GetSpans(p);
  }

  // Ensure column exists and return it.
  getOrCreateColumnAtFine(xi, zi){
    const xm = (xi / SUB) | 0;
    const zm = (zi / SUB) | 0;
    if(xm<0||zm<0||xm>=this.widthM||zm>=this.heightM) return null;
    return this.space.GetOrCreateColumnByMeter(xm, zm);
  }

  // Terrain editing (1m low precision)
  setTerrainAtMeter(mx, mz, heightUnits, texture){
    const col = this.space.GetOrCreateColumnByMeter(mx, mz);
    if(!col) return;
    col.Terrain = new Span(0, heightUnits|0, texture|0);

    // Maintain mask: if no obstacles => terrain-only
    if(col.HighPrecision){
      // keep HP obstacles
      col.Mask = 0;
      return;
    }
    if(col.Other && col.Other.length){
      col.Mask = 2;
    } else {
      col.Mask = 1;
      col.Other = null;
    }
  }

  // Low precision obstacle spans (1m)
  addLowPrecisionSpanAtMeter(mx, mz, span){
    const col = this.space.GetOrCreateColumnByMeter(mx, mz);
    if(!col) return;
    // 你补充的规则：
    // - 1mx1m 中只要出现过任何高精阻挡（HighPrecision != nil），那么 Other 必须为 nil。
    // - 之后即使再“低精方式”设置阻挡，也不能把列降回低精；
    //   而是把这段 low-precision 的 span 复制写入 16 个子格（等价于“整格阻挡”）。
    if(col.HighPrecision){
      for(let i=0;i<16;i++){
        col.HighPrecision.Spans[i].push(new Span(span.MinY, span.MaxY, span.Texture));
        col.HighPrecision.Spans[i].sort((a,b)=> (a.MaxY-b.MaxY) || (a.MinY-b.MinY));
      }
      col.Other = null;
      col.Mask = 0; // HP
      return;
    }

    if(!col.Other) col.Other = [];
    col.Other.push(span);
    col.Other.sort((a,b)=> (a.MaxY-b.MaxY) || (a.MinY-b.MinY));
    col.Mask = 2;
  }

  // High precision obstacle spans (0.25m)
  addHighPrecisionSpanAtFine(xi, zi, span){
    const col = this.getOrCreateColumnAtFine(xi,zi);
    if(!col) return;
    // Ensure HP mode
    if(!col.HighPrecision){
      col.HighPrecision = new HighPrecisionColumn();
      // 如果此前是低精（Other 里有整格阻挡），需要把它们复制到 16 个子格里
      if(col.Other && col.Other.length){
        for(let i=0;i<16;i++){
          for(const s of col.Other){
            col.HighPrecision.Spans[i].push(new Span(s.MinY, s.MaxY, s.Texture));
          }
          col.HighPrecision.Spans[i].sort((a,b)=> (a.MaxY-b.MaxY) || (a.MinY-b.MinY));
        }
      }
    }
    col.Other = null;
    col.Mask = 0; // HP
    const xo = xi & (SUB-1);
    const zo = zi & (SUB-1);
    const gi = (xo*4+zo)|0;
    col.HighPrecision.Spans[gi].push(span);
    col.HighPrecision.Spans[gi].sort((a,b)=> (a.MaxY-b.MaxY) || (a.MinY-b.MinY));
  }

  // Erase obstacles (LP or HP) at a specific fine cell.
  eraseObstaclesAtFine(xi, zi, mode='auto'){
    const col = this.getOrCreateColumnAtFine(xi,zi);
    if(!col) return;

    if(col.HighPrecision){
      const xo = xi & (SUB-1);
      const zo = zi & (SUB-1);
      const gi = (xo*4+zo)|0;
      col.HighPrecision.Spans[gi] = [];
      // If all empty => downgrade to terrain-only (or LP if there is Other, but we keep none)
      let any=false;
      for(let i=0;i<16;i++){ if(col.HighPrecision.Spans[i].length){ any=true; break; } }
      if(!any){
        col.HighPrecision = null;
        col.Mask = 1;
        col.Other = null;
      }
      return;
    }
    // LP
    col.Other = null;
    col.Mask = 1;
  }

  clearAllObstacles(){
    // Iterate all chunks and clear obstacles
    for(let i=0;i<this.space.Map.length;i++){
      const ch = this.space.Map[i];
      if(!ch) continue;
      for(const col of ch.cols){
        col.Other = null;
        col.HighPrecision = null;
        col.Mask = 1;
      }
    }
  }
}

// =============================== Collision / Landing Logic (3D) ===============================
// Apply ignoreTexture rule: "only ignore the part above current foot height"
function effectiveSpans(spans, ignoreTexMask, curY){
  // Go 版语义（map.go 注释 + 你补充的说明）：
  // - Texture 是 bitmask；Span.Texture 可能是多个 bit 的复合。
  // - 当 (Span.Texture & ignoreTexMask) != 0 时，该 Span “可被忽略”。
  // - 但只能忽略“高于当前落脚点 curY 的部分”，即：
  //   - span 全在 curY 以下/等于：仍然阻挡
  //   - span 全在 curY 以上：整段认为是空隙（完全忽略）
  //   - span 跨越 curY：仅保留 [MinY, curY) 这一段为阻挡
  const m = (ignoreTexMask|0);
  if(!m) return spans;
  const y = (curY|0);
  const out = [];

  for(const s of spans){
    const tex = (s.Texture|0);
    if((tex & m) === 0){
      out.push(s);
      continue;
    }

    const a0 = (s.MinY|0);
    const a1 = (s.MaxY|0);

    if(a1 <= y){
      // 完全在当前落脚点以下：仍然阻挡
      out.push(s);
      continue;
    }
    if(a0 >= y){
      // 完全在当前落脚点之上：整段忽略
      continue;
    }
    // 跨越 curY：仅保留 below 部分
    if(y > a0){
      out.push(new Span(a0, y, tex));
    }
  }

  out.sort((a,b)=> (a.MaxY-b.MaxY) || (a.MinY-b.MinY));
  return out;
}

// Body collision test against spans: collide if [y, y+h) overlaps with [MinY,MaxY] (touching at y is OK)
function bodyCollides(spansAll, y, h){
  const y0 = y|0;
  const y1 = (y + h)|0;
  for(const s of spansAll){
    const a0 = s.MinY|0;
    const a1 = s.MaxY|0;
    // overlap if a0 < y1 && a1 > y0
    if(a0 < y1 && a1 > y0) return true;
  }
  return false;
}

// Find the highest span top <= y in a cell (after ignore). Return {top, texture} or null.
function highestFloorAtOrBelow(spansAll, y){
  // 返回：<=y 的最高“地面”高度，以及该高度处的 Texture（同高度多个 Span 则按 OR 合并）
  const yy = y|0;
  let bestTop = -1;
  let texMask = 0;
  for(const s of spansAll){
    const top = s.MaxY|0;
    if(top <= yy){
      if(top > bestTop){
        bestTop = top;
        texMask = (s.Texture|0);
      } else if(top === bestTop){
        texMask |= (s.Texture|0);
      }
    }
  }
  if(bestTop < 0) return null;
  return {top: bestTop|0, texture: texMask|0};
}

// Gather candidate "floor heights" (span.MaxY) from a cell (after ignore) that are potentially standable.
// We keep all textures here; standable check is done at footprint-level for the global max floor.
function candidateFloorsFromCell(spansAll){
  const out = [];
  for(const s of spansAll){
    out.push(s.MaxY|0);
  }
  return out;
}

// Validate a pose at fine bottom-left (xi,zi) with bottom height yUnits.
// Footprint fixed to 2x2 subcells: (xi,zi), (xi+1,zi), (xi,zi+1), (xi+1,zi+1)
function poseValid(map, xi, zi, yUnits, params, curYForIgnore){
  const {agentHUnits, banTexMask, ignoreTexMask} = params;
  // footprint bounds
  if(!map.inFineBounds(xi,zi) || !map.inFineBounds(xi+1,zi+1)) return {ok:false, reason:'out of bounds'};
  const cells = [
    [xi,zi],[xi+1,zi],[xi,zi+1],[xi+1,zi+1],
  ];

  // Build effective spans for each cell
  const perCell = [];
  for(const [xj,zj] of cells){
    const [terrain, obs] = map.getSpansAtFine(xj,zj, yUnits);
    if(!terrain) return {ok:false, reason:'missing terrain'};
    const all = [terrain, ...obs];
    const eff = effectiveSpans(all, ignoreTexMask, curYForIgnore|0);
    perCell.push(eff);
  }

  // Collision check: body at [y, y+agentH)
  for(const spans of perCell){
    if(bodyCollides(spans, yUnits|0, agentHUnits|0)){
      return {ok:false, reason:'body collides'};
    }
  }

  // Determine global floor = max over cells of highest span top <= y
  let floorTop = -1;
  let floorTex = null;
  for(const spans of perCell){
    const f = highestFloorAtOrBelow(spans, yUnits|0);
    if(!f) return {ok:false, reason:'no floor'};
    if(f.top > floorTop){
      floorTop = f.top;
      floorTex = f.texture;
    }
  }

  // Require bottom touches the global floor (no floating)
  if(floorTop !== (yUnits|0)){
    return {ok:false, reason:'floating'};
  }

  // Floor texture must be standable
  if((banTexMask|0) !== 0 && (((floorTex|0) & (banTexMask|0)) !== 0)){
    return {ok:false, reason:'banned texture'};
  }

  return {ok:true, reason:'ok'};
}

// Compute candidate landing y's at target (xi,zi) given current y (for ignore rule & step constraints)
function landingCandidates(map, xi, zi, curY, params){
  const {stepUpUnits, stepDownUnits, banTexMask, ignoreTexMask} = params;
  // footprint bounds
  if(!map.inFineBounds(xi,zi) || !map.inFineBounds(xi+1,zi+1)) return [];

  const cells = [
    [xi,zi],[xi+1,zi],[xi,zi+1],[xi+1,zi+1],
  ];

  // Build effective spans per cell (ignore relative to curY)
  const perCell = [];
  for(const [xj,zj] of cells){
    const [terrain, obs] = map.getSpansAtFine(xj,zj, curY|0);
    const all = [terrain, ...obs];
    const eff = effectiveSpans(all, ignoreTexMask, curY|0);
    perCell.push(eff);
  }

  // Candidate y's: union of all span tops in footprint (after ignore)
  const cand = new Set();
  for(const spans of perCell){
    for(const y of candidateFloorsFromCell(spans)){
      cand.add(y|0);
    }
  }
  const ys = Array.from(cand).sort((a,b)=>a-b);

  const out = [];
  for(const y of ys){
    // Step constraints relative to curY
    const dy = (y|0) - (curY|0);
    if(dy > 0 && dy > (stepUpUnits|0)) continue;
    if(dy < 0 && (-dy) > (stepDownUnits|0)) continue;

    // Pose valid at this y?
    // (poseValid will also apply ignore & banTex & collision)
    const ok = poseValid(map, xi, zi, y|0, params, curY|0);
    if(ok.ok) out.push(y|0);
  }

  return out;
}

// =============================== A* / MRA* Solver (3D states: x,z,y) ===============================
class MinHeap {
  constructor(){ this.arr=[]; }
  size(){ return this.arr.length; }
  peek(){ return this.arr[0]; }
  push(n){ this.arr.push(n); this._up(this.arr.length-1); }
  pop(){
    if(this.arr.length===0) return null;
    const top=this.arr[0];
    const last=this.arr.pop();
    if(this.arr.length){ this.arr[0]=last; this._down(0); }
    return top;
  }
  _up(i){
    while(i>0){
      const p=(i-1)>>1;
      const A=this.arr[p], B=this.arr[i];
      if(A.f < B.f || (A.f===B.f && A.g<=B.g)) break;
      [this.arr[p],this.arr[i]]=[this.arr[i],this.arr[p]];
      i=p;
    }
  }
  _down(i){
    const n=this.arr.length;
    while(true){
      let l=i*2+1, r=l+1, m=i;
      const better=(a,b)=>{
        const A=this.arr[a], B=this.arr[b];
        return (A.f < B.f) || (A.f===B.f && A.g < B.g);
      };
      if(l<n && better(l,m)) m=l;
      if(r<n && better(r,m)) m=r;
      if(m===i) break;
      [this.arr[m],this.arr[i]]=[this.arr[i],this.arr[m]];
      i=m;
    }
  }
}

function key(step, x, z, y){ return `${step}|${x}|${z}|${y}`; }

function euclidXZ(a,b){
  const dx = (a.x-b.x)*CELL;
  const dz = (a.z-b.z)*CELL;
  return Math.hypot(dx,dz);
}

function moveCost(step, diag){
  const d = diag ? Math.SQRT2 : 1;
  return d * (step * CELL);
}

function neighborsXZ(x, z, step){
  // 8-connected
  const dirs = [
    [ step, 0],[-step, 0],[0, step],[0,-step],
    [ step, step],[ step,-step],[-step, step],[-step,-step]
  ];
  const out=[];
  for(const [dx,dz] of dirs){
    out.push({x:x+dx, z:z+dz, diag:(dx!==0 && dz!==0), dx, dz});
  }
  return out;
}

function coincideIndicesXZ(x,z, steps){
  const idx=[];
  for(let i=0;i<steps.length;i++){
    const r=steps[i];
    if((x%r===0) && (z%r===0)) idx.push(i);
  }
  return idx;
}

function makeSearch(step, weight){
  return {
    step, weight,
    open: new MinHeap(),
    g: new Map(),
    closed: new Set(),
    parent: new Map(),
    expanded: 0,
  };
}

function pushOrUpdate(search, node, g, parentKey, h){
  const k = key(search.step, node.x, node.z, node.y);
  const old = search.g.get(k);
  if(old!==undefined && g>=old) return;
  search.g.set(k,g);
  search.parent.set(k,parentKey);
  const f = g + search.weight*h;
  search.open.push({x:node.x, z:node.z, y:node.y, g, h, f});
}

function reconstruct(search, goalKey){
  const out=[];
  let k = goalKey;
  const seen=new Set();
  while(k && !seen.has(k)){
    seen.add(k);
    const parts = k.split('|');
    // parts: step|x|z|y
    out.push({x:+parts[1], z:+parts[2], y:+parts[3]});
    k = search.parent.get(k);
  }
  out.reverse();
  return out;
}

// Check a move for a given step by simulating fine (1-subcell) increments.
// Returns list of possible landing y's at the target.
function simulateMove(map, from, toX, toZ, step, params){
  const dx = toX - from.x;
  const dz = toZ - from.z;
  const stepsCount = Math.max(Math.abs(dx), Math.abs(dz));
  if(stepsCount===0) return [];

  const sx = Math.sign(dx);
  const sz = Math.sign(dz);

  // candidate Ys at current position
  let curSet = [from.y|0];

  let cx = from.x|0;
  let cz = from.z|0;

  for(let i=0;i<stepsCount;i++){
    const nx = cx + sx;
    const nz = cz + sz;
    const nextSet = new Set();

    for(const yCur of curSet){
      const cands = landingCandidates(map, nx, nz, yCur|0, params);
      for(const yN of cands) nextSet.add(yN|0);
    }

    const arr = Array.from(nextSet).sort((a,b)=>a-b);
    // prune: keep up to 6 heights to avoid explosion
    curSet = arr.slice(0,6);

    cx = nx; cz = nz;
    if(curSet.length===0) return [];
  }

  return curSet;
}

function buildSolver(map, cfg){
  const steps = cfg.algo==='mra' ? [1,2,4] : [1];
  const anchorIdx = 0;
  const searches = steps.map(r => makeSearch(r, cfg.w1));

  const start = {...cfg.start}; // {x,z,y}
  const goal  = {...cfg.goal};

  // seed (for each resolution that aligns in x,z)
  const initIdx = coincideIndicesXZ(start.x, start.z, steps);
  for(const i of initIdx){
    const s = searches[i];
    const h = euclidXZ(start, goal);
    pushOrUpdate(s, start, 0, null, h);
  }

  function chooseQueue(){
    // Similar gate logic as the given 2D html: compare g+h vs w2*(anchor g+h)
    const anchor = searches[anchorIdx];
    if(anchor.open.size()===0) return anchorIdx;
    const a = anchor.open.peek();
    const anchorMin = a.g + a.h;

    let best = anchorIdx;
    let bestF = anchorMin;
    if(searches.length>=2 && searches[2].open.size()!==0) {
      for(let i=0;i<searches.length;i++){
        if(i===anchorIdx) continue;
        const s=searches[i];
        if(s.open.size()===0) continue;
        const n=s.open.peek();
        const f=n.g + n.h;
        if(f <= cfg.w2 * anchorMin){
          if(best===anchorIdx || f<=bestF){
            best=i; bestF=f;
          }
        }
      }
    }
    return best;
  }

  let done=false;
  let found=false;
  let path=[];
  let msg='';

  function stepOnce(){
    if(done) return {done,found,path,msg};

    // all empty?
    let any=false;
    for(const s of searches){ if(s.open.size()>0){ any=true; break; } }
    if(!any){ done=true; found=false; msg='OPEN 全空：无解'; return {done,found,path,msg}; }

    const qi = (cfg.algo==='mra') ? chooseQueue() : 0;
    const s = searches[qi];

    let cur = s.open.pop();
    while(cur){
      const ck = key(s.step, cur.x, cur.z, cur.y);
      if(!s.closed.has(ck)) break;
      cur = s.open.pop();
    }
    if(!cur){ msg='当前队列为空（跳过）'; return {done,found,path,msg}; }

    const ck = key(s.step, cur.x, cur.z, cur.y);
    s.closed.add(ck);
    s.expanded++;

    // goal test (anchor only to match the 2D behavior)
    if(qi===anchorIdx && cur.x===goal.x && cur.z===goal.z && cur.y===goal.y){
      done=true; found=true;
      path = reconstruct(s, ck);
      msg='Anchor 到达终点：成功';
      return {done,found,path,msg};
    }

    // expand neighbors
    for(const nb of neighborsXZ(cur.x, cur.z, s.step)){
      const nx = nb.x|0, nz = nb.z|0;
      // bounds: footprint 2x2 => need +1
      if(nx<0||nz<0||nx>=map.widthFine-1||nz>=map.heightFine-1) continue;

      // simulate move by fine steps to respect stepUp/down & 3D clearance
      const landingYs = simulateMove(map, {x:cur.x,z:cur.z,y:cur.y}, nx, nz, s.step, cfg.params);
      if(landingYs.length===0) continue;

      for(const ny of landingYs){
        const nk = key(s.step, nx, nz, ny);
        if(s.closed.has(nk)) continue;

        const ng = cur.g + moveCost(s.step, nb.diag);
        const h = euclidXZ({x:nx,z:nz}, goal);
        pushOrUpdate(s, {x:nx,z:nz,y:ny}, ng, ck, h);


        if(cfg.algo==='mra' && s.step > 1) {
          const isStraight = nb.x===cur.x || nb.y===cur.y
          if (isStraight) {
            if ((cfg.goal.x >= cur.x && cfg.goal.x <= nb.x && cfg.goal.y === nb.y) || (cfg.goal.x >= nb.x && cfg.goal.x <= cur.x && cfg.goal.y === nb.y) || (cfg.goal.y >= cur.y && cfg.goal.y <= nb.y && cfg.goal.x === nb.x) || (cfg.goal.y >= nb.y && cfg.goal.y <= cur.y && cfg.goal.x === nb.x)) {
              done=true; found=true;
              path = reconstruct(s, cfg.goal, s.step);
              msg='Anchor 到达终点：成功';
              return {done,found,path,msg};
            }
          } else {
            if ((Math.abs(cfg.goal.x-cur.x) === Math.abs(cfg.goal.y-cur.y) && Math.abs(cfg.goal.x-cur.x) <= s.step) &&
                    ((cfg.goal.x >= cur.x && cfg.goal.x <= nb.x && cfg.goal.y >= cur.y && cfg.goal.y <= nb.y ) ||
                            (cfg.goal.x >= nb.x && cfg.goal.x <= cur.x && cfg.goal.y >= cur.y && cfg.goal.y <= nb.y) ||
                            (cfg.goal.x >= cur.x && cfg.goal.x <= nb.x && cfg.goal.y >= nb.y && cfg.goal.y <= cur.y) ||
                            (cfg.goal.x >= nb.x && cfg.goal.x <= cur.x && cfg.goal.y >= nb.y && cfg.goal.y <= cur.y) )) {
              done=true; found=true;
              path = reconstruct(s, cfg.goal, s.step);
              msg='Anchor 到达终点：成功';
              return {done,found,path,msg};
            }
          }
        }

        // share seeds across resolutions if coincident in x,z
        if(cfg.algo==='mra'){
          const idxs = coincideIndicesXZ(nx, nz, steps);
          for(const j of idxs){
            if(j===qi) continue;
            const sj = searches[j];
            const jk = key(sj.step, nx, nz, ny);
            if(sj.closed.has(jk)) continue;
            pushOrUpdate(sj, {x:nx,z:nz,y:ny}, ng, ck, h);
          }
        }
      }
    }

    msg = `扩展：Q${qi} (r=${s.step}, w=${s.weight}) @ (${cur.x},${cur.z}, y=${uToM(cur.y).toFixed(2)}m)`;
    return {done,found,path,msg};
  }

  return {
    steps, searches, stepOnce,
    get done(){return done;},
    get found(){return found;},
    get path(){return path;},
  };
}

// =============================== 3D Renderer (Canvas 2D, perspective) ===============================
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');

const el = id => document.getElementById(id);
const statEl = el('stat');
const inspEl = el('inspect');

function resizeCanvas(){
  const wrap = cv.parentElement;
  const w = wrap.clientWidth;
  const h = wrap.clientHeight;
  cv.width = Math.floor(w * devicePixelRatio);
  cv.height = Math.floor(h * devicePixelRatio);
  cv.style.width = w+'px';
  cv.style.height = h+'px';
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}

const camera = {
  yaw: 0.9,
  pitch: 0.55,
  dist: 40,
  target: {x: 0, y: 0, z: 0},
  fov: Math.PI/3,
};

let __camBasisCache = null;
function getCamBasis(){
  if(__camBasisCache) return __camBasisCache;

  const cy = Math.cos(camera.yaw), sy = Math.sin(camera.yaw);
  const cp = Math.cos(camera.pitch), sp = Math.sin(camera.pitch);

  // eye position (spherical around target)
  const eye = {
    x: camera.target.x + camera.dist * cp * cy,
    y: camera.target.y + camera.dist * sp,
    z: camera.target.z + camera.dist * cp * sy,
  };

  // forward points from eye to target
  let fx = camera.target.x - eye.x;
  let fy = camera.target.y - eye.y;
  let fz = camera.target.z - eye.z;
  const fl = Math.hypot(fx,fy,fz) || 1;
  fx/=fl; fy/=fl; fz/=fl;

  // world up
  const ux0=0, uy0=1, uz0=0;

  // right = normalize(cross(forward, up))
  let rx = fy*uz0 - fz*uy0;
  let ry = fz*ux0 - fx*uz0;
  let rz = fx*uy0 - fy*ux0;
  const rl = Math.hypot(rx,ry,rz) || 1;
  rx/=rl; ry/=rl; rz/=rl;

  // up = cross(right, forward)
  const ux = ry*fz - rz*fy;
  const uy = rz*fx - rx*fz;
  const uz = rx*fy - ry*fx;

  __camBasisCache = {eye, forward:{x:fx,y:fy,z:fz}, right:{x:rx,y:ry,z:rz}, up:{x:ux,y:uy,z:uz}};
  return __camBasisCache;
}
function invalidateCamBasis(){ __camBasisCache = null; }



function project(pt){
  const W = cv.clientWidth, H = cv.clientHeight;
  const aspect = W / H;
  const {eye, forward, right, up} = getCamBasis();
  const dx = pt.x - eye.x;
  const dy = pt.y - eye.y;
  const dz = pt.z - eye.z;

  const cx = dx*right.x + dy*right.y + dz*right.z;
  const cy = dx*up.x + dy*up.y + dz*up.z;
  const cz = dx*forward.x + dy*forward.y + dz*forward.z;

  if(cz <= 0.01) return null;

  const f = 1 / Math.tan(camera.fov/2);
  const xN = (cx * f / aspect) / cz;
  const yN = (cy * f) / cz;

  const sx = (xN * 0.5 + 0.5) * W;
  const sy = (-yN * 0.5 + 0.5) * H;

  return {x:sx, y:sy, z:cz};
}

function rayFromScreen(sx, sy){
  const W = cv.clientWidth, H = cv.clientHeight;
  const aspect = W / H;
  const xN = (sx / W) * 2 - 1;
  const yN = -((sy / H) * 2 - 1);

  const {eye, forward, right, up} = getCamBasis();
  const f = 1 / Math.tan(camera.fov/2);

  // direction in world: forward + right*(xN*aspect/f) + up*(yN/f)
  const dx = forward.x + right.x*(xN*aspect/f) + up.x*(yN/f);
  const dy = forward.y + right.y*(xN*aspect/f) + up.y*(yN/f);
  const dz = forward.z + right.z*(xN*aspect/f) + up.z*(yN/f);
  const dl = Math.hypot(dx,dy,dz) || 1;
  return {o:eye, d:{x:dx/dl, y:dy/dl, z:dz/dl}};
}

function intersectPlaneY0(ray){
  const {o,d} = ray;
  if(Math.abs(d.y) < 1e-6) return null;
  const t = (0 - o.y) / d.y;
  if(t <= 0) return null;
  return {x:o.x + d.x*t, y:0, z:o.z + d.z*t, t};
}

// Simple color helpers
function hexToRgb(hex){
  const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  if(!m) return {r:255,g:255,b:255};
  return {r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16)};
}
function rgbToHex(r,g,b){
  const to = (v)=> ('0'+clamp(v|0,0,255).toString(16)).slice(-2);
  return '#'+to(r)+to(g)+to(b);
}
function shade(hex, k){
  const c=hexToRgb(hex);
  return rgbToHex(c.r*k, c.g*k, c.b*k);
}

// texture->color (extendable)
function texColor(tex){
  switch(tex|0){
    case 1: return '#2c3a2c'; // terrain
    case 2: return '#1f3a5a'; // water
    case 3: return '#263241'; // wall
    case 4: return '#5a3a1f'; // door/wood
    default: return '#333a46';
  }
}

// draw a box aligned with axes. x,z in meters; sizes in meters; y0,y1 in meters.
function drawBox(x0, z0, sx, sz, y0, y1, baseColor, depthKey){
  // visible faces: top + 2 sides depending on camera direction
  const {eye} = getCamBasis();
  const cx = x0 + sx/2;
  const cz = z0 + sz/2;

  // determine which sides face camera
  const dx = eye.x - cx;
  const dz = eye.z - cz;
  const sideX = dx >= 0 ? 'L' : 'R';
  const sideZ = dz >= 0 ? 'F' : 'B'; // front/back relative to z

  // vertices
  const x1=x0+sx, z1=z0+sz;
  const yb=y0, yt=y1;

  // Define 8 corners
  const p000={x:x0,y:yb,z:z0}, p100={x:x1,y:yb,z:z0}, p010={x:x0,y:yt,z:z0}, p110={x:x1,y:yt,z:z0};
  const p001={x:x0,y:yb,z:z1}, p101={x:x1,y:yb,z:z1}, p011={x:x0,y:yt,z:z1}, p111={x:x1,y:yt,z:z1};

  const polys = [];

  // Top face
  polys.push({pts:[p010,p110,p111,p011], color:shade(baseColor,1.15), depth:depthKey + yt});

  // Side faces (two)
  if(sideX==='L'){
    polys.push({pts:[p000,p001,p011,p010], color:shade(baseColor,0.92), depth:depthKey + (yb+yt)/2});
  } else {
    polys.push({pts:[p100,p110,p111,p101], color:shade(baseColor,0.92), depth:depthKey + (yb+yt)/2});
  }

  if(sideZ==='F'){
    polys.push({pts:[p000,p100,p110,p010], color:shade(baseColor,0.82), depth:depthKey + (yb+yt)/2});
  } else {
    polys.push({pts:[p001,p101,p111,p011], color:shade(baseColor,0.82), depth:depthKey + (yb+yt)/2});
  }

  for(const poly of polys){
    const pr = poly.pts.map(project).filter(Boolean);
    if(pr.length !== 4) continue;
    ctx.beginPath();
    ctx.moveTo(pr[0].x, pr[0].y);
    for(let i=1;i<pr.length;i++) ctx.lineTo(pr[i].x, pr[i].y);
    ctx.closePath();
    ctx.fillStyle = poly.color;
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }
}

function drawLine3D(points, color, width=2){
  const pr = points.map(project).filter(Boolean);
  if(pr.length<2) return;
  ctx.beginPath();
  ctx.moveTo(pr[0].x, pr[0].y);
  for(let i=1;i<pr.length;i++) ctx.lineTo(pr[i].x, pr[i].y);
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.stroke();
}

function drawPoint3D(p, color, r=3){
  const pr = project(p);
  if(!pr) return;
  ctx.beginPath();
  ctx.arc(pr.x, pr.y, r, 0, Math.PI*2);
  ctx.fillStyle = color;
  ctx.fill();
}

// =============================== App State ===============================
const state = {
  map: new MapData(32,32),
  solver: null,
  running: false,
  timer: null,
  lastMsg: '',
  tool: 'terrain',
  brush: 1,

  // start/goal in fine indices & y units
  start: {x: 2, z: 2, y: 0},
  goal:  {x: 10, z: 10, y: 0},

  // selection for inspect
  sel: {xi:0, zi:0, mx:0, mz:0, gi:0, valid:false},
};

// Initialize camera target
function resetCameraTarget(){
  const w = state.map.widthM, h = state.map.heightM;
  camera.target = {x: w/2, y: 0, z: h/2};
  camera.dist = Math.max(w,h) * 1.4 + 10;
}
resetCameraTarget();

// =============================== Inspect Panel ===============================
function setSelectionFromFine(xi, zi){
  const mx = (xi/SUB)|0;
  const mz = (zi/SUB)|0;
  const xo = xi & (SUB-1);
  const zo = zi & (SUB-1);
  const gi = (xo*4+zo)|0;
  state.sel = {xi,zi,mx,mz,gi, valid:true};
  updateInspect();
}

function updateInspect(){
  const s = state.sel;
  if(!s.valid){
    inspEl.innerHTML = '<div class="hint">未选中</div>';
    return;
  }
  // read column
  const [col, ok] = state.map.space.GetColumnByMeter(s.mx, s.mz);
  let kind = '未分配（默认 terrain-only）';
  let terrain = new Span(0,0,1);
  let obs = [];
  if(ok && col){
    terrain = col.Terrain;
    if(col.ColumnIsTerrain()) kind='Terrain-only';
    else if(col.ColumnIsLowPrecision()) kind='LowPrecision';
    else kind='HighPrecision';
    // build PointForSearchPath for this fine cell
    const p = new PointForSearchPath(s.mx, s.mz, (s.xi&3), (s.zi&3), 0);
    const got = col.GetSpans(p);
    obs = got[1]||[];
  }

  const lines = [];
  function kv(k,v){ lines.push(`<div>${k}</div><div>${v}</div>`); }
  kv('选中 Fine', `(${s.xi}, ${s.zi})`);
  kv('选中 Meter', `(${s.mx}, ${s.mz})`);
  kv('GridIndex', `${s.gi}`);
  kv('Column 类型', kind);
  kv('Terrain', `[0, ${uToM(terrain.MaxY).toFixed(2)}] tex=${terrain.Texture}`);
  kv('Obstacle 数', `${obs.length}`);
  let html = lines.join('');
  if(obs.length){
    html += `<div style="grid-column:1/3; height:8px"></div>`;
    html += `<div style="grid-column:1/3; color:var(--muted); font-size:12px">Obstacle Spans（本子格视角）</div>`;
    for(let i=0;i<obs.length;i++){
      const sp = obs[i];
      html += `<div style="grid-column:1/3; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace; font-size:12px; padding:6px 8px; border:1px solid var(--line); border-radius:10px; margin-top:6px; background:#0b0d10;">
        #${i} [${uToM(sp.MinY).toFixed(2)}, ${uToM(sp.MaxY).toFixed(2)}] tex=${sp.Texture}
      </div>`;
    }
  }
  inspEl.innerHTML = html;
}

// =============================== Solver Config Builders ===============================
function buildParams(){
  const agentHUnits = mToU(parseFloat(el('agentH').value||'1.1'));
  const stepUpUnits = mToU(parseFloat(el('stepUp').value||'1.1'));
  const stepDownUnits = mToU(parseFloat(el('stepDown').value||'65535'));
  const banTexMask = parseTexMask(el('banTex').value);
  const ignoreTexMask = (parseInt(el('ignoreTex').value||'0',10) || 0) | 0;

  return {agentHUnits, stepUpUnits, stepDownUnits, banTexMask, ignoreTexMask};
}

// Determine a deterministic start/goal y by selecting the lowest feasible floor that has clearance
function chooseInitialYAt(xi, zi, params){
  // Use curY = 0 for ignore rule (no ignore effect), and no step constraints (set huge)
  const p2 = {...params, stepUpUnits: 65535, stepDownUnits: 65535};
  const cands = landingCandidates(state.map, xi, zi, 0, p2);
  if(cands.length===0) return 0;
  return cands[0]|0;
}

function rebuildSolver(){
  const params = buildParams();

  // Validate start/goal in-bounds
  if(!state.map.inFineBounds(state.start.x,state.start.z) || !state.map.inFineBounds(state.start.x+1,state.start.z+1)){
    state.lastMsg='起点越界（需要 2x2 footprint 空间）';
    state.solver=null;
    updateStat(); render();
    return;
  }
  if(!state.map.inFineBounds(state.goal.x,state.goal.z) || !state.map.inFineBounds(state.goal.x+1,state.goal.z+1)){
    state.lastMsg='终点越界（需要 2x2 footprint 空间）';
    state.solver=null;
    updateStat(); render();
    return;
  }

  // 起点/终点 Y 选择：
  // - 自动：按“最低可落脚点”吸附（方便快速摆放）
  // - 手动：严格使用输入的 y；如果在阻挡里/净空不足则直接失败（符合你的要求）
  const endYMode = el('endYMode').value;
  if(endYMode === 'auto'){
    state.start.y = chooseInitialYAt(state.start.x, state.start.z, params);
    state.goal.y  = chooseInitialYAt(state.goal.x, state.goal.z, params);
    // 让面板显示出当前吸附到的 y
    el('startY').value = uToM(state.start.y).toFixed(2);
    el('goalY').value  = uToM(state.goal.y).toFixed(2);
  } else {
    state.start.y = mToU(parseFloat(el('startY').value||'0'));
    state.goal.y  = mToU(parseFloat(el('goalY').value||'0'));
  }

  // Validate pose at chosen y
  const okS = poseValid(state.map, state.start.x, state.start.z, state.start.y, params, state.start.y);
  const okG = poseValid(state.map, state.goal.x, state.goal.z, state.goal.y, params, state.goal.y);
  if(!okS.ok || !okG.ok){
    state.solver=null;
    state.lastMsg=`起点或终点无效：start=${okS.reason}, goal=${okG.reason}`;
    updateStat(); render();
    return;
  }

  const cfg = {
    algo: el('algo').value,
    w1: parseFloat(el('w1').value||'2'),
    w2: parseFloat(el('w2').value||'1.5'),
    start: {...state.start},
    goal: {...state.goal},
    params,
  };

  state.solver = buildSolver(state.map, cfg);
  state.lastMsg='已初始化，等待开始';
  updateStat();
  render();
}

function stopRun(){
  state.running=false;
  if(state.timer) clearInterval(state.timer);
  state.timer=null;
  el('run').disabled=false;
  el('pause').disabled=true;
}

function startRun(){
  if(!state.solver) rebuildSolver();
  if(!state.solver) return;
  stopRun();
  state.running=true;
  el('run').disabled=true;
  el('pause').disabled=false;
  const tickMs = Math.floor(1000 / (+el('speed').value));
  state.timer = setInterval(()=>{
    if(!state.solver || state.solver.done){
      stopRun(); updateStat(); render(); return;
    }
    const r = state.solver.stepOnce();
    state.lastMsg = r.msg;
    updateStat();
    render();
  }, tickMs);
}

function stepOnceUI(){
  if(!state.solver) rebuildSolver();
  if(!state.solver) return;
  if(state.solver.done) return;
  const r = state.solver.stepOnce();
  state.lastMsg = r.msg;
  updateStat();
  render();
}

function runToFinish(){
  if(!state.solver) rebuildSolver();
  if(!state.solver) return;
  stopRun();
  let guard=0;
  while(state.solver && !state.solver.done && guard<200000){
    const r = state.solver.stepOnce();
    state.lastMsg = r.msg;
    guard++;
  }
  if(guard>=200000) state.lastMsg = 'Guard 达到上限，停止（可能无解或地图过大）';
  updateStat();
  render();
}

function resetAll(){
  stopRun();
  const w = clamp(parseInt(el('mapW').value||'32',10), 32, 512);
  const h = clamp(parseInt(el('mapH').value||'32',10), 32, 512);

  // enforce multiples of 32
  const W = Math.round(w/32)*32;
  const H = Math.round(h/32)*32;
  el('mapW').value = W;
  el('mapH').value = H;

  state.map.resize(W,H);
  resetCameraTarget();

  // default start/goal
  state.start = {x:2, z:2, y:0};
  state.goal  = {x: state.map.widthFine-6, z: state.map.heightFine-6, y:0};

  // 同步端点 Y（自动/手动模式）
  // 注意：syncEndpointYUI 会刷新 UI，我们在其后再把状态文案改回“已重置”。
  try { syncEndpointYUI(); } catch(_) {}

  state.solver=null;
  state.lastMsg='已重置';
  resizeCanvas();
  updateStat();
  render();
}

function clearObstacles(){
  stopRun();
  state.map.clearAllObstacles();
  state.solver=null;
  state.lastMsg='已清空阻挡（保留地形）';
  updateStat();
  render();
}

// =============================== Stats / Rendering ===============================
function updateStat(){
  const algo = el('algo').value;
  let txt='';
  if(!state.solver){
    txt = '状态：未开始\n' + (state.lastMsg||'');
  } else {
    const s = state.solver.searches;
    const expanded = s.map(x=>x.expanded);
    const openSizes = s.map(x=>x.open.size());
    txt = `算法：${algo.toUpperCase()}  |  子格：0.25m  |  footprint：2×2\n` +
          `Start: (${state.start.x},${state.start.z}, y=${uToM(state.start.y).toFixed(2)}m)\n` +
          `Goal : (${state.goal.x},${state.goal.z}, y=${uToM(state.goal.y).toFixed(2)}m)\n` +
          `Expanded per queue: [${expanded.join(', ')}]\n` +
          `OPEN sizes: [${openSizes.join(', ')}]\n` +
          `${state.lastMsg || ''}`;
    if(state.solver.done){
      txt += state.solver.found ? '\n结果：找到路径（紫色）' : '\n结果：无解';
    }
  }
  statEl.textContent = txt;
}

// Build render lists from map + solver state
function render(){
  invalidateCamBasis();
  const W = cv.clientWidth, H = cv.clientHeight;
  ctx.clearRect(0,0,W,H);

  // background
  ctx.fillStyle = '#0f1318';
  ctx.fillRect(0,0,W,H);

  // Map extents (meters)
  const mapW = state.map.widthM;
  const mapH = state.map.heightM;

  // Base ground plane (y=0)
  const planePts = [
    {x:0,y:0,z:0},
    {x:mapW,y:0,z:0},
    {x:mapW,y:0,z:mapH},
    {x:0,y:0,z:mapH},
  ].map(project).filter(Boolean);
  if(planePts.length===4){
    ctx.beginPath();
    ctx.moveTo(planePts[0].x, planePts[0].y);
    for(let i=1;i<4;i++) ctx.lineTo(planePts[i].x, planePts[i].y);
    ctx.closePath();
    ctx.fillStyle = '#0d1218';
    ctx.fill();
  }

  // Grid lines on ground (adaptive)
  let minor = 4;
  const big = Math.max(mapW,mapH);
  if(big <= 64) minor = 1;
  else if(big <= 128) minor = 2;
  else minor = 4;

  // minor grid
  ctx.globalAlpha = 0.28;
  for(let x=0; x<=mapW; x+=minor){
    drawLine3D([{x:x,y:0.01,z:0},{x:x,y:0.01,z:mapH}], 'rgba(27,34,48,1)', 1);
  }
  for(let z=0; z<=mapH; z+=minor){
    drawLine3D([{x:0,y:0.01,z:z},{x:mapW,y:0.01,z:z}], 'rgba(27,34,48,1)', 1);
  }

  // chunk grid (32m)
  ctx.globalAlpha = 0.55;
  for(let x=0; x<=mapW; x+=32){
    drawLine3D([{x:x,y:0.02,z:0},{x:x,y:0.02,z:mapH}], 'rgba(42,123,214,1)', 1.5);
  }
  for(let z=0; z<=mapH; z+=32){
    drawLine3D([{x:0,y:0.02,z:z},{x:mapW,y:0.02,z:z}], 'rgba(42,123,214,1)', 1.5);
  }
  ctx.globalAlpha = 1;

  // Collect boxes (terrain + obstacles) for depth sorting
  const boxes = [];

  // Terrain: 1m columns
  // Only draw at meter resolution (since terrain always low precision by requirement)
  for(let mz=0;mz<mapH;mz++){
    for(let mx=0;mx<mapW;mx++){
      // fetch column if exists; else default
      const [col, ok] = state.map.space.GetColumnByMeter(mx,mz);
      let terr = ok && col ? col.Terrain : new Span(0,0,1);
      const hM = uToM(terr.MaxY|0);
      if(hM<=0) continue; // flat ground -> skip height (still navigable)
      const baseCol = texColor(terr.Texture|0);
      boxes.push({
        x:mx, z:mz, sx:1, sz:1,
        y0:0, y1:hM,
        color:baseCol,
      });
    }
  }

  // Obstacles: iterate allocated chunks only
  for(const ch of state.map.space.Map){
    if(!ch) continue;
    for(let idx=0; idx<ch.cols.length; idx++){
      const col = ch.cols[idx];
      // Determine meter coordinate inside chunk
      // chunk origin is not stored; we approximate by scanning later via selection; simpler: compute via index
      // We cannot know which chunk this column belongs to from here; so we skip direct iteration.
      // Instead, we render obstacles by scanning meter cells and checking column kind (still OK for <= 256x256).
    }
  }

  // For simplicity and correctness, render obstacles by scanning meter cells (same cost as terrain scan).
  for(let mz=0;mz<mapH;mz++){
    for(let mx=0;mx<mapW;mx++){
      const [col, ok] = state.map.space.GetColumnByMeter(mx,mz);
      if(!ok || !col) continue;
      if(col.ColumnIsTerrain()) continue;

      // low precision obstacles
      if(col.ColumnIsLowPrecision()){
        const spans = col.Other || [];
        for(const sp of spans){
          const y0=uToM(sp.MinY|0), y1=uToM(sp.MaxY|0);
          boxes.push({x:mx,z:mz,sx:1,sz:1,y0,y1,color:texColor(sp.Texture|0)});
        }
      } else {
        // high precision: per subcell
        const hp = col.HighPrecision;
        if(!hp) continue;
        for(let gi=0;gi<16;gi++){
          const arr = hp.Spans[gi] || [];
          if(!arr.length) continue;
          const xo = (gi/4)|0; // XOffSet
          const zo = gi & 3;   // ZOffSet
          const x0 = mx + xo*CELL;
          const z0 = mz + zo*CELL;
          for(const sp of arr){
            const y0=uToM(sp.MinY|0), y1=uToM(sp.MaxY|0);
            boxes.push({x:x0,z:z0,sx:CELL,sz:CELL,y0,y1,color:texColor(sp.Texture|0)});
          }
        }
      }
    }
  }

  // Depth sorting (approx by projecting box center)
  const sortable = [];
  for(const b of boxes){
    const c = {x:b.x + b.sx/2, y:(b.y0+b.y1)/2, z:b.z + b.sz/2};
    const pr = project(c);
    if(!pr) continue;
    sortable.push({b, depth: pr.z});
  }
  sortable.sort((a,b)=> b.depth - a.depth);

  // Draw boxes back-to-front
  for(const it of sortable){
    const b = it.b;
    drawBox(b.x, b.z, b.sx, b.sz, b.y0, b.y1, b.color, it.depth);
  }

  // Draw start/goal markers (tall)
  const sPos = fineToWorldCenter(state.start.x, state.start.z, uToM(state.start.y));
  const gPos = fineToWorldCenter(state.goal.x, state.goal.z, uToM(state.goal.y));
  drawPoint3D({x:sPos.x,y:sPos.y+0.2,z:sPos.z}, '#2a7bd6', 6);
  drawPoint3D({x:gPos.x,y:gPos.y+0.2,z:gPos.z}, '#d66f2a', 6);
  // vertical stems
  drawLine3D([{x:sPos.x,y:0,z:sPos.z},{x:sPos.x,y:sPos.y+1.5,z:sPos.z}], 'rgba(42,123,214,.7)', 2);
  drawLine3D([{x:gPos.x,y:0,z:gPos.z},{x:gPos.x,y:gPos.y+1.5,z:gPos.z}], 'rgba(214,111,42,.7)', 2);

  // Draw solver overlays
  if(state.solver){
    // Path
    const pts = (state.solver.path||[]).map(n => fineToWorldCenter(n.x,n.z,uToM(n.y)));
    if(pts.length>=2) drawLine3D(pts, 'rgba(122,76,214,.9)', 3);

    // OPEN/CLOSED (sample for performance)
    const searches = state.solver.searches;
    const anchor = searches[0];

    const openArr = anchor.open.arr;
    const maxPts = 2500;

    // OPEN
    for(let i=0;i<openArr.length && i<maxPts;i++){
      const n=openArr[i];
      const p = fineToWorldCenter(n.x,n.z,uToM(n.y));
      drawPoint3D({x:p.x,y:p.y+0.05,z:p.z}, 'rgba(27,59,34,.85)', 2.4);
    }

    // CLOSED union
    // Build a sampled list of closed points across queues
    let closedPts = [];
    for(const s of searches){
      let c=0;
      for(const k of s.closed){
        if(c++ > 800) break; // sample per queue
        const parts = k.split('|');
        const x=+parts[1], z=+parts[2], y=+parts[3];
        const p = fineToWorldCenter(x,z,uToM(y));
        closedPts.push(p);
      }
    }
    closedPts = closedPts.slice(0, maxPts);
    for(const p of closedPts){
      drawPoint3D({x:p.x,y:p.y+0.05,z:p.z}, 'rgba(59,43,27,.75)', 2.2);
    }
  }

  // Selected cell highlight
  if(state.sel.valid){
    const mx = state.sel.mx, mz = state.sel.mz;
    // draw a thin rectangle on ground
    const corners = [
      {x:mx, y:0.01, z:mz},
      {x:mx+1, y:0.01, z:mz},
      {x:mx+1, y:0.01, z:mz+1},
      {x:mx, y:0.01, z:mz+1},
      {x:mx, y:0.01, z:mz},
    ];
    drawLine3D(corners, 'rgba(255,255,255,.6)', 2);
  }

  // Info overlay
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(10,10, 270, 78);
  ctx.fillStyle = 'rgba(230,232,235,0.9)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  ctx.fillText(`Map: ${state.map.widthM}m x ${state.map.heightM}m  (fine ${state.map.widthFine}x${state.map.heightFine})`, 18, 30);
  ctx.fillText(`Tool: ${state.tool}  |  Brush: ${state.brush}`, 18, 48);
  ctx.fillText(`Cam: yaw ${camera.yaw.toFixed(2)}  pitch ${camera.pitch.toFixed(2)}  dist ${camera.dist.toFixed(1)}`, 18, 66);
}

function fineToWorldCenter(xi, zi, yM){
  // node represents bottom-left of footprint; we render at its center-ish
  // footprint is 2x2 subcells => 0.5m; center offset 0.25m
  return {
    x: xi*CELL + 0.25,
    y: yM,
    z: zi*CELL + 0.25,
  };
}

// =============================== Editing Tools ===============================
function setTool(name){
  state.tool=name;
  for(const t of document.querySelectorAll('.tool')){
    t.classList.toggle('active', t.dataset.tool===name);
  }
}

document.getElementById('toolbar').addEventListener('click', (e)=>{
  const t = e.target.closest('.tool');
  if(!t) return;
  setTool(t.dataset.tool);
});

el('brush').addEventListener('change', ()=>{ state.brush = parseInt(el('brush').value,10)||0; });

function paintAtFine(xi, zi, opts={}){
  const tool = opts.tool || state.tool;
  const brush = opts.brush ?? state.brush;

  // Apply paint in a square brush on fine grid for HP/erase/start/goal; meter brush for terrain/LP
  const tH = mToU(parseFloat(el('terrainH').value||'0'));
  const tTex = parseInt(el('terrainTex').value||'1',10)||1;

  const bMin = mToU(parseFloat(el('blkMin').value||'0'));
  const bMax = mToU(parseFloat(el('blkMax').value||'2'));
  const bTex = parseInt(el('blkTex').value||'3',10)||3;

  const span = new Span(Math.min(bMin,bMax), Math.max(bMin,bMax), bTex);

  // helper: iterate fine cells within brush
  const applyFine = (fn)=>{
    for(let dz=-brush; dz<=brush; dz++){
      for(let dx=-brush; dx<=brush; dx++){
        const x = xi+dx, z = zi+dz;
        if(!state.map.inFineBounds(x,z)) continue;
        fn(x,z);
      }
    }
  };

  // helper: iterate meter cells affected (brush in fine translated to meter)
  const applyMeter = (fn)=>{
    const mx0 = ((xi-brush)/SUB)|0;
    const mz0 = ((zi-brush)/SUB)|0;
    const mx1 = ((xi+brush)/SUB)|0;
    const mz1 = ((zi+brush)/SUB)|0;
    for(let mz=mz0;mz<=mz1;mz++){
      for(let mx=mx0;mx<=mx1;mx++){
        if(mx<0||mz<0||mx>=state.map.widthM||mz>=state.map.heightM) continue;
        fn(mx,mz);
      }
    }
  };

  stopRun();
  state.solver=null;

  if(tool==='terrain'){
    applyMeter((mx,mz)=>{
      state.map.setTerrainAtMeter(mx,mz,tH,tTex);
    });
    state.lastMsg='已编辑地形（需要重新开始）';
    return;
  }

  if(tool==='blockLP'){
    applyMeter((mx,mz)=>{
      state.map.addLowPrecisionSpanAtMeter(mx,mz,new Span(span.MinY, span.MaxY, span.Texture));
    });
    state.lastMsg='已添加低精阻挡（需要重新开始）';
    return;
  }

  if(tool==='blockHP'){
    applyFine((x,z)=>{
      state.map.addHighPrecisionSpanAtFine(x,z,new Span(span.MinY, span.MaxY, span.Texture));
    });
    state.lastMsg='已添加高精阻挡（需要重新开始）';
    return;
  }

  if(tool==='erase'){
    applyFine((x,z)=>{
      state.map.eraseObstaclesAtFine(x,z);
    });
    state.lastMsg='已擦除阻挡（需要重新开始）';
    return;
  }

  if(tool==='start'){
    // start uses bottom-left of 2x2 footprint
    const sx = clamp(xi, 0, state.map.widthFine-2);
    const sz = clamp(zi, 0, state.map.heightFine-2);
    const endYMode = el('endYMode').value;
    let sy = 0;
    if(endYMode === 'auto'){
      const params = buildParams();
      sy = chooseInitialYAt(sx, sz, params);
      el('startY').value = uToM(sy).toFixed(2);
    } else {
      sy = mToU(parseFloat(el('startY').value||'0'));
    }
    state.start = {x: sx, z: sz, y: sy|0};
    state.lastMsg='已设置起点（需要重新开始）';
    return;
  }

  if(tool==='goal'){
    const gx = clamp(xi, 0, state.map.widthFine-2);
    const gz = clamp(zi, 0, state.map.heightFine-2);
    const endYMode = el('endYMode').value;
    let gy = 0;
    if(endYMode === 'auto'){
      const params = buildParams();
      gy = chooseInitialYAt(gx, gz, params);
      el('goalY').value = uToM(gy).toFixed(2);
    } else {
      gy = mToU(parseFloat(el('goalY').value||'0'));
    }
    state.goal = {x: gx, z: gz, y: gy|0};
    state.lastMsg='已设置终点（需要重新开始）';
    return;
  }

  if(tool==='inspect'){
    setSelectionFromFine(xi,zi);
    state.lastMsg='已选中单元';
    return;
  }
}

// =============================== Pointer / Camera Interaction ===============================
let pointer = {
  mode: null, // 'orbit'|'pan'|'paint'
  id: null,
  lastX: 0,
  lastY: 0,
  lastCellKey: null,
  moved: false,
};

function cellFromEvent(e){
  const rect = cv.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const ray = rayFromScreen(sx, sy);
  const hit = intersectPlaneY0(ray);
  if(!hit) return null;

  // convert world meters -> fine indices
  const xi = Math.floor(hit.x / CELL);
  const zi = Math.floor(hit.z / CELL);
  if(!state.map.inFineBounds(xi,zi)) return null;
  return {xi,zi,mx:hit.x,mz:hit.z};
}

cv.addEventListener('contextmenu', (e)=> e.preventDefault());

cv.addEventListener('pointerdown', (e)=>{
  cv.setPointerCapture(e.pointerId);
  pointer.id = e.pointerId;
  pointer.lastX = e.clientX;
  pointer.lastY = e.clientY;
  pointer.moved = false;

  // Right button => orbit
  if(e.button === 2 || (e.button===0 && e.shiftKey)){
    pointer.mode = 'orbit';
    return;
  }
  // Middle => pan
  if(e.button === 1){
    pointer.mode = 'pan';
    return;
  }

  // Left => paint / inspect
  if(e.button === 0){
    const cell = cellFromEvent(e);
    if(!cell) return;

    const tool = (e.ctrlKey ? 'inspect' : state.tool);
    paintAtFine(cell.xi, cell.zi, {tool});
    pointer.mode = 'paint';
    pointer.lastCellKey = `${cell.xi}|${cell.zi}|${tool}`;
    updateStat();
    render();
  }
});

cv.addEventListener('pointermove', (e)=>{
  if(pointer.id !== e.pointerId) return;
  const dx = e.clientX - pointer.lastX;
  const dy = e.clientY - pointer.lastY;
  pointer.lastX = e.clientX;
  pointer.lastY = e.clientY;
  if(Math.abs(dx)+Math.abs(dy) > 2) pointer.moved = true;

  if(pointer.mode === 'orbit'){
    camera.yaw += dx * 0.005;
    camera.pitch += dy * 0.005;
    camera.pitch = clamp(camera.pitch, 0.15, 1.35);
    render();
    return;
  }

  if(pointer.mode === 'pan'){
    // pan target in camera right/up plane
    const {right, up} = getCamBasis();
    const s = camera.dist * 0.002;
    camera.target.x += (-dx*right.x + dy*up.x) * s;
    camera.target.y += (-dx*right.y + dy*up.y) * s;
    camera.target.z += (-dx*right.z + dy*up.z) * s;
    render();
    return;
  }

  if(pointer.mode === 'paint'){
    const cell = cellFromEvent(e);
    if(!cell) return;
    const tool = (e.ctrlKey ? 'inspect' : state.tool);
    const k = `${cell.xi}|${cell.zi}|${tool}`;
    if(k === pointer.lastCellKey) return;
    pointer.lastCellKey = k;
    paintAtFine(cell.xi, cell.zi, {tool});
    updateStat();
    render();
    return;
  }
});

function endPointer(e){
  if(pointer.id !== e.pointerId) return;
  pointer.mode = null;
  pointer.id = null;
  pointer.lastCellKey = null;
}

cv.addEventListener('pointerup', endPointer);
cv.addEventListener('pointercancel', endPointer);

cv.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const delta = Math.sign(e.deltaY);
  camera.dist *= (delta>0) ? 1.08 : 0.92;
  camera.dist = clamp(camera.dist, 5, 600);
  render();
},{passive:false});

// =============================== UI Hooks ===============================
el('reset').onclick = resetAll;
el('clear').onclick = clearObstacles;
el('step').onclick = stepOnceUI;
el('run').onclick = startRun;
el('pause').onclick = ()=>{ stopRun(); state.lastMsg='已暂停'; updateStat(); };
el('finish').onclick = runToFinish;

['algo','w1','w2','agentH','stepUp','stepDown','banTex','ignoreTex'].forEach(id=>{
  el(id).addEventListener('change', ()=>{ stopRun(); state.solver=null; state.lastMsg='参数改变（需要重新开始）'; updateStat(); render(); });
});
el('speed').addEventListener('input', ()=>{ if(state.running){ startRun(); } });

// 端点 Y 相关（自动/手动）
function syncEndpointYUI(){
  const mode = el('endYMode').value;
  const params = buildParams();

  if(mode === 'auto'){
    el('startY').disabled = true;
    el('goalY').disabled = true;
    state.start.y = chooseInitialYAt(state.start.x, state.start.z, params);
    state.goal.y  = chooseInitialYAt(state.goal.x,  state.goal.z,  params);
    el('startY').value = uToM(state.start.y).toFixed(2);
    el('goalY').value  = uToM(state.goal.y).toFixed(2);
  } else {
    el('startY').disabled = false;
    el('goalY').disabled = false;
    state.start.y = mToU(parseFloat(el('startY').value||'0'));
    state.goal.y  = mToU(parseFloat(el('goalY').value||'0'));
  }

  stopRun();
  state.solver = null;
  state.lastMsg = '端点高度/模式改变（需要重新开始）';
  updateStat();
  render();
}

el('endYMode').addEventListener('change', syncEndpointYUI);
el('startY').addEventListener('input', ()=>{
  if(el('endYMode').value !== 'manual') return;
  state.start.y = mToU(parseFloat(el('startY').value||'0'));
  stopRun(); state.solver=null; state.lastMsg='起点 Y 改变（需要重新开始）'; updateStat(); render();
});
el('goalY').addEventListener('input', ()=>{
  if(el('endYMode').value !== 'manual') return;
  state.goal.y = mToU(parseFloat(el('goalY').value||'0'));
  stopRun(); state.solver=null; state.lastMsg='终点 Y 改变（需要重新开始）'; updateStat(); render();
});

['mapW','mapH'].forEach(id=>{
  el(id).addEventListener('change', ()=> resetAll());
});

// init
window.addEventListener('resize', ()=>{ resizeCanvas(); render(); });
resizeCanvas();
resetAll();
setTool('terrain');
</script>
</body>
</html>
